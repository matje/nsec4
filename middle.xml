<section title="Introduction" anchor="introduction">
  <section title="Rationale" anchor="rationale">
  <t>
  bla bla bla. NSEC + NSEC3 = NSEC4.
  Reduces bandwidth.
  Only one type of authenticated denial of existence: nsec4, not two.
  </t>
  <t>
  In addition to NSEC3, a NSEC4 records needs store the following items:
  </t>
  <t>
  <list style="symbols">
    <t>was there a wildcard at the original owner name;</t>
  </list>
  </t>
  <t>
  Unlike NSEC3, NSEC4 defines a zero hash, which leaves the domain
  names in tact.
  </t>
  </section>
 
  <section title="Requirements" anchor="requirements">
  <t>
  The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
  "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL"
  in this document are to be interpreted as described in
  <xref target="RFC2119"/>.
  </t>
  </section>

  <section title="Terminology" anchor="terminology">
  <t>
  The reader is assumed to be familiar with the basic DNS and DNSSEC concepts
  described in <xref target="RFC1034"/>, <xref target="RFC1035"/>,
  <xref target="RFC4033"/>, <xref target="RFC4034"/>, <xref target="RFC4035"/>
  and subsequent RFCs that update them: <xref target="RFC2136"/>,
  <xref target="RFC2181"/>, <xref target="RFC2308"/>, and
  <xref target="RFC5155"/>.
  </t>
  <t>
  The same terminology is used throughout this document as in Section 1.3
  from <xref target="RFC5155"/>, with the following changes:
  </t>
  <t>
  <list style="hanging">
    <t hangText="Opt-Out NSEC4 RR: ">
    a NSEC4 RR that has the Opt-Out flag set to 1.
    </t>
    <t hangText="Opt-Out zone: ">
    a zone with at least one Opt-Out NSEC4 RR.
    </t>
    <t hangText="Base32: ">
    the "Base 32 Encoding with Extended Hex Alphabet" as specified in
    <xref target="RFC4648"/>. Note that trailing padding characters ("=") are
    not used in the NSEC4 specification.
    </t>
    <t hangText="To cover: ">
    When a hash algorithm is defined,
    a NSEC4 RR is said to "cover" a name if the hash of the name or
    "next closer" name falls between the owner name and the next hashed
    owner name of the NSEC4. When no hash algorithm is defined, a NSEC4 RR is
    said to "cover" a name if the name or "next closer" name falls between
    the owner name and the next owner name of the NSEC4. In other words, if
    it proves the nonexistence of the name, either directly or by proving the
    nonexistence of an ancestor of the name.
    </t>
    <t hangText="To match: ">
    When a hash algorithm is defined, a NSEC4 RR is said to "match" a name
    if the owner name of the NSEC4 RR is the same as the hashed owner name
    of that name. When no hash algorithm is defined, a NSEC4 RR is said to
    "match" a name if the name and the owner name of the NSEC4 RR are equal.
    </t>
  </list>
  </t>
  </section>
</section>

<section title="The NSEC4 Resource Record" anchor="the-nsec4-resource-record">
<t>
The NSEC4 Resource Record (RR) provides authenticated denial of existence
for DNS RRsets.
</t>
<t>
The NSEC4 RR lists RR types present at the original owner name of the NSEC4 RR.
It includes the next (hashed) owner name in the (hash) order of the zone.
The complete set of NSEC4 RRs in a zone indicates which RRSets exist for the
original owner name of the RR and form a chain. This information is used to
provide authenticated denial of existence for DNS data. To provide protection
against zone enumeration, the owner names used in the NSEC4 RR can be
cryptographic hashes of the original owner name prepended as a single label
to the name of the zone. If hashing is used, the NSEC4 RR indicates which
hash function is used to construct the hash, which salt is used, and how many
iterations of the hash function are performed over the original owner name.
The hashing technique is described fully in
<xref target="calculation-of-the-hash"/>.
</t>
<t>
(Hashed) owner names of unsigned delegations may be excluded from the chain.
A NSEC4 RR whose span covers an owner name or "next closer" name of an
unsigned delegation is referred to as an Opt-Out NSEC4 RR and is indicated by
the presence of a flag.
</t>
<t>
If hashing is in use, the owner name for the NSEC4 RR is the base32 encoding
of the hashed owner name prepended as a single label to the name of the zone.
</t>
<t>
The type value for the NSEC4 RR is [TBD1].
</t>
<t>
The NSEC4 RR RDATA format is class independent and is described below.
</t>
<t>
The class MUST be the same as the class of the original owner name.
</t>
<t>
The NSEC4 RR SHOULD have the same TTL value as the SOA minimum TTL field.
This is in the spirit of negative caching <xref target="RFC2136"/>.
</t>

  <section title="NSEC4 RDATA Wire Format" anchor="nsec4-rdata-wire-format">
  <t>
  Differences with NSEC3:
  </t>
  <t>
  <list style="symbols">
    <t>
    Flags have a bit reserved to indicate whether wildcard name expansion is
    possible at the original owner name;
    </t>
    <t>
     Hash length does not need to be stored, all domain names are stored
     as domain names, not raw hashes;
    </t>
  </list>
  </t>
  <t>
    The RDATA of the NSEC4 RR is as shown below and has many similarities
    with NSEC3 <xref target="RFC5155"/>.
  </t>

  <figure><artwork>
                      1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   Hash Alg.   |     Flags     |          Iterations           |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |  Salt Length  |                     Salt                      /
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 /                 Next (Hashed) Owner Name                      /
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                         Type Bit Maps                         /
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</artwork></figure>

  <t>
  Hash Algorithm is a single octet.
  If Hash Algorithm is zero (no hashing), the Iterations field,
  Salt Length field and Salt field are omitted.
  </t>
  <t>
  Flags field is a single octet. The following one-bit flags are defined:
  </t>

  <figure><artwork>
 0 1 2 3 4 5 6 7
+-+-+-+-+-+-+-+-+
|           |W|O|
+-+-+-+-+-+-+-+-+

  </artwork></figure>

  <t>
  <list style="symbols">
  <t>O - Opt-Out flag</t>
  <t>W - Wildcard flag</t>
  </list>
  </t>
  <t>
  Iterations, if present, is represented as a 16-bit unsigned integer,
  with the most significant bit first.
  </t>
  <t>
  Salt Length, if present, is represented as an unsigned octet. Salt Length
  represents the length of the Salt field in octets. If the value is
  zero, the following Salt field is omitted.
  </t>
  <t>
  Salt, if present, is encoded as a sequence of binary octets. The
  length of this field is determined by the preceding Salt Length
  field.
  </t>
  <t>
  The Next (Hashed) Owner Name is a base32 encoded domain name,
  if Hash Algorithm is is not zero. If Hash Algorithm is zero it is a plain
  domain name.
  </t>
  <t>
  The Type Bit Maps encode the existing types at the original owner name
  that matches the NSEC4 RR.
  </t>
  <t>
  [MM: We might be able to do something smart with the label count,
       like NSEC does.]
  Label Count is represented as a 8-bit unsigned integer, and represents the
  number of labels of the owner name in its unhashed format. It is used to
  determine the closest encloser of the name that matches the NSEC4 RR.
  [MM: But we still can't use it for NXDOMAIN responses. Unhashed NXDOMAIN is
       no problem, because the source of synthesis (*.closest_encloser)
       always is the next of the closest encloser. But hashed, this order is
       screwed.]
  </t>
  </section>
  <section title="Presentation Format" anchor="nsec4-presentation-format">
  <t>
  NSEC record:
  </t>
  <figure><artwork>
example.org. NSEC a.example.org. NS SOA RRSIG DNSKEY NSEC3PARAM
  </artwork></figure>
  <t>
  NSEC3 record:
  </t>
  <figure><artwork>
15BG9L6359F5CH23E34DDUA6N1RIHL9H.example.org. NSEC3 1 0 2 DEAD
 22670TRPLHSR72PQQMEDLTG1KDQEOLB7 NS SOA RRSIG DNSKEY NSEC3PARAM
  </artwork></figure>
  <t>
  NSEC4 record with zero hashing:
  </t>
  <figure><artwork>
example.org. NSEC4 0 0 a.example.org. NS SOA RRSIG DNSKEY NSEC4PARAM
  </artwork></figure>
  <t>
  NSEC4 record with hashing:
  </t>
  <figure><artwork>
15BG9L6359F5CH23E34DDUA6N1RIHL9H.example.org. NSEC4 1 0 2 DEAD
 22670TRPLHSR72PQQMEDLTG1KDQEOLB7.example.org.
 NS SOA RRSIG DNSKEY NSEC4PARAM
  </artwork></figure>
  </section>
</section>

<section title="The NSEC4PARAM Resource Record" anchor="the-nsec4param-resource-record">
<t>
Like NSEC3PARAM
</t>
</section>

<section title="Calculation of the Hash" anchor="calculation-of-the-hash">
<t>
Like NSEC3.
</t>
</section>

<section title="Authoritative Server Considerations" anchor="authoritative-server-considerations">
  <section title="Zone Serving" anchor="zone-serving">
  <t>
  This specification modifies DNSSEC-enabled DNS responses generated by
  authoritative servers. In particular, it replaces the use of NSEC or
  NSEC3 RRs in such responses with NSEC4 RRs.
  </t>

    <section title="Denial of Source of Synthesis Proof" anchor="denial-of-source-of-synthesis-proof">
    <t>
    With NSEC3, many responses require the closest encloser proof. The closest
    encloser is used to determine:
    </t>
    <t>
    <list style="symbols">
      <t>
      the "next closer" name, used in a Name Error responses to proof that
      QNAME does not exist, and used in Wildcard No Data responses to proof
      that the wildcard name expansion was valid;
      </t>
      <t>
      the source of synthesis, used in Name Error responses to proof that
      wildcard name expansion was not possible, and used in Wildcard No Data
      responses to proof that the wildcard does not have the required RRset.
      </t>
      <t>
      the RRsets at the closest encloser, used to determine if the denial
      of existence is from the proper zone and does not cross authoritative
      boundaries.
      </t>
    </list>
    </t>
    <t>
    In many cases, it is actually not a necessity to transmit the closest
    encloser, it is just for convenience. The closest encloser is only
    required for the authenticated denial of existence of the source of
    synthesis. This has now been covered with that addition of the Wildcard
    bit in the Flags field.
    </t>
    <t>
    The Denial of Source of Synthesis proof consists of one NSEC4 RR, that:
    </t>
    <t>
    <list style="symbols">
      <t>matches the closest (provable) encloser;</t>
      <t>has the Wildcard bit not set.</t>
    </list>
    </t>
    <t>
    This is a proof that some ancestor of the QNAME is the closest encloser of
    QNAME. To proof that no wildcard expansion was possible, we check that the
    Wildcard bit was not set.
    </t>
    </section>

    <section title="Name Error Responses" anchor="serving-name-error-responses">
    <t>
    If the zone does not contain any RRsets matching QNAME either exactly or
    via wildcard name expansion, then the name server must include proof that:
    </t>
    <t>
    <list style="symbols">
      <t>there is no exact match for QNAME;</t>
      <t>thee zone contains no RRsets that would QNAME via wildcard name
         expansion.</t>
    </list>
    </t>
    <t>
    With NSEC, the server includes in the response a NSEC RR that covers QNAME,
    and a NSEC RR that covers the wildcard RR at the closest encloser.
    </t>
    <t>
    With NSEC3, the server includes in the response a NSEC3 RR that covers the
    next closer, a NSEC3 RR that covers the wildcard RR at the closest
    encloser, and a NSEC3 RR that matches the closest encloser.
    [MM: Instead or returning the NSEC3 RR that covers the next closer,
         the server could have returned the NSEC3 RR that covers the QNAME in
         order to proof that there is no exact match for QNAME.]
    </t>
    <t>
    To prove the nonexistence of QNAME with NSEC4, the server MUST include in
    the response a NSEC4 RR that covers the next closer, and a NSEC4 RR that
    matches the closest encloser. The NSEC4 RR that matches the closest
    encloser MUST NOT have the Wildcard bit set in the Flags field.
    </t>
    </section>

    <section title="No Data Responses" anchor="serving-no-data-responses">
    <t>
    When a NODATA response needs to be returned, it is safe to say that QNAME
    exists. Just like with NSEC and NSEC3, if the QTYPE does not equal DS,
    the server MUST include the NSEC4 RR that matches QNAME. This NSEC4 RR
    MUST NOT have the bits corresponding to either the QTYPE or CNAME set in
    its Type Bit Maps field.
    </t>
    <t>
    Because of Opt-Out, the response can be different when QTYPE is DS. If no
    NSEC4 RR matches QNAME, the server MUST return a closest provable encloser
    proof for QNAME. In other words, the server MUST include in the response
    a NSEC4 RR that covers the next closer, and a NSEC4 RR that matches the
    closest provable encloser. Note that we do not need to proof the
    nonexistence of the source of synthesis, because a DS RRset next to a
    wildcard is meaningless (Section 4.6, <xref target="RFC4592"/>).
    </t>
    </section>

    <section title="Wildcard Answer Responses" anchor="serving-wildcard-answer-responses">
    <t>
    If the zone does not contain any RRsets matching QNAME, but there is
    wildcard name expansion possible then the name server must include proof
    that the wildcard match was valid. This proof is accomplished by proving
    that QNAME does not exist and that the closest encloser of QNAME and the
    immediate ancestor of the wildcard are equal.
    </t>
    <t>
    Both with NSEC and NSEC3, the server includes in the response a NSEC RR
    that covers the next closer. It is not necessary to return a RR that
    matches the closest encloser, as the existence of this closest encloser
    is proven by the presence of the expanded wildcard in the response.
    </t>
    <t>
    To prove that the wildcard name expansion was valid with NSEC4, the server
    MUST include in the response a NSEC4 RR that covers the next closer.
    </t>
    </section>

    <section title="Wildcard No Data Responses" anchor="serving-wildcard-no-data-responses">
    <t>
    With NSEC, the server includes in the response a NSEC RR that matches the
    wildcard, in addition to the the NSEC RR that covers the next closer. The
    NSEC RR does not have the bits corresponding to QTYPE or CNAME set in its
    Type Bit Maps field.
    </t>
    <t>
    Again, with NSEC3, the server includes in the response a NSEC3 RR that
    matches the wildcard, in addition to the the NSEC3 RR that covers the next
    closer. The NSEC3 RR does not have the bits corresponding to QTYPE or
    CNAME set in its Type Bit Maps field. Besides that, a NSEC3 RR that
    matches the closest encloser is included, because there was no expanded
    wildcard in the response that can be used to determine the closest
    encloser.
    </t>
    <t>
    To prove the wildcard no data response with NSEC4, the server MUST include
    in the response a NSEC4 RR that matches the wildcard, and a NSEC4 RR that
    covers the next closer. We do not need to include a RR that matches the
    closest encloser, as it can be derived from the NSEC4 RR that matches the
    wildcard. From that, the next closer can be derived.
    </t>
    </section>

    <section title="Referrals to Unsigned Subzones" anchor="serving-referrals-to-unsigned-subzones">
    <t>
    Like <xref target="serving-no-data-responses"/> with QTYPE is DS.
    </t>
    </section>

    <section title="Responding to Queries for NSEC4 Owner Names" anchor="responding-to-queries-for-nsec4-owner-names">
    <t>
    To do.
    </t>
    </section>

    <section title="Server Response to a Run-Time Collision" anchor="server-response-to-a-run-time-collision">
    <t>
    To do.
    </t>
    </section>
  </section>
</section>

<section title="IANA Considerations" anchor="iana-considerations">
<t>
This memo includes requests to IANA.
</t>
</section>

<section title="Security Considerations" anchor="security-considerations">
<t>
This document does not introduce any new security issues beyond those
already discussed in <xref target="RFC4033">RFC4033</xref>,
<xref target="RFC4034">RFC4034</xref>. <xref target="RFC4035">RFC4035</xref>
and <xref target="RFC5155">RFC5155</xref>.
</t>
</section>

<section title="Changelog" anchor="changelog">
  <section title="00">
  <t>
  <list>
    <t>- Initial document</t>
  </list>
  </t>
  </section>
</section>


