# Introduction

## Rationale
Changes compared to NSEC and NSEC3:
* Remove the need for three NSEC3 records, but optimizing the wildcard NSEC away. This
  saves a record and a signature from the answer;
* One unified denial of existence method, in stead of two: NSEC and NSEC3.

In addition to NSEC3, a NSEC4 records needs store the following items:
* was there a wildcard at the original owner name;

## Requirements
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and
"OPTIONAL" in this document are to be interpreted as described in [](#RFC2119).

## Terminology
The same terminology is used throughout this document as in Section 1.3
from [](#RFC5155), with the following changes:

Opt-Out NSEC4 RR:

:   a NSEC4 RR that has the Opt-Out flag set to 1.

Wildcard NSEC4 RR:

:   a NSEC4 RR that has the Wildcard flag set to 1.

Opt-Out zone:

:   a zone with at least one Opt-Out NSEC4 RR.

Base32:

:   the "Base 32 Encoding with Extended Hex Alphabet" as specified in
    [](#RFC4648). Note that trailing padding characters ("=") are
    not used in the NSEC4 specification.

To cover:

:   When a hash algorithm is defined,
    a NSEC4 RR is said to "cover" a name if the hash of the name or
    "next closer" name falls between the owner name and the next hashed
    owner name of the NSEC4. When no hash algorithm is defined, a NSEC4 RR is
    said to "cover" a name if the name or "next closer" name falls between
    the owner name and the next owner name of the NSEC4. In other words, if
    it proves the nonexistence of the name, either directly or by proving the
    nonexistence of an ancestor of the name.

To match:

:   When a hash algorithm is defined, a NSEC4 RR is said to "match" a name
    if the owner name of the NSEC4 RR is the same as the hashed owner name
    of that name. When no hash algorithm is defined, a NSEC4 RR is said to
    "match" a name if the name and the owner name of the NSEC4 RR are equal.


# The NSEC4 Resource Record

The NSEC4 Resource Record (RR) provides authenticated denial of existence
for DNS RRsets.

The NSEC4 RR lists RR types present at the original owner name of the NSEC4 RR.
It includes the next (hashed) owner name in the (hash) order of the zone.
The complete set of NSEC4 RRs in a zone indicates which RRSets exist for the
original owner name of the RR and form a chain. This information is used to
provide authenticated denial of existence for DNS data. To provide protection
against zone enumeration, the owner names used in the NSEC4 RR can be
cryptographic hashes of the original owner name prepended as a single label
to the name of the zone. If hashing is used, the NSEC4 RR indicates which
hash function is used to construct the hash, which salt is used, and how many
iterations of the hash function are performed over the original owner name.

The hashing technique is described in [](#calculation-of-the-hash).

(Hashed) owner names of unsigned delegations may be excluded from the chain.
A NSEC4 RR whose span covers an owner name or "next closer" name of an
unsigned delegation is referred to as an Opt-Out NSEC4 RR and is indicated by
the presence of a flag.

If hashing is in use, the owner name for the NSEC4 RR is the base32 encoding
of the hashed owner name prepended as a single label to the name of the zone.

The type value for the NSEC4 RR is [TBD1].

The NSEC4 RR RDATA format is class independent and is described below.

The class MUST be the same as the class of the original owner name.

The NSEC4 RR SHOULD have the same TTL value as the SOA minimum TTL field.
This is in the spirit of negative caching [](#RFC2136).

## RDATA Fields

### Hash Algorithm

[](#RFC5155) defines the NSEC3 hash algorithm registry. The zero
hash (hash algorithm 0) is reserved. For NSEC4 we define hash
algorithm zero to mean that nothing is hashed in the record. MG: beter.

### Flags

The Flags field is identical to the Flags field as defined in [](#RFC5155). 
This specification adds a new flag, the Wildcard Flag.

#### Opt-Out Flag

Like the Opt-Out Flag defined in Section 3.1.2.1 of [](#RFC5155).

#### Wildcard Flag

...

### Iterations

Like the Iterations field defined in Section 3.1.3 of [](#RFC5155).

### Salt Length

Like the Salt Length field defined in Section 3.1.4 of [](#RFC5155).

### Salt

Like the Salt field defined in Section 3.1.5 of [](#RFC5155).

### Next (Hashed) Owner Name

### Type Bit Maps

Like the Type But Maps field defined in Section 3.1.8 of [](#RFC5155).

## NSEC4 RDATA Wire Format

The NSEC4 RDATA has many similarities with NSEC3, but there are a few differences:
* There is an extra flag bit reserved to indicate whether wildcard name expansion is
  possible at the original owner name; [MG] wat is de original owner name. [MM] de unhashed name
* the hash length does not need to be stored, as all domain names are stored as domain 
  names, not raw hashes;

The RDATA of the NSEC4 RR is as shown below.

                         1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Hash Alg.   |     Flags     |          Iterations           |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |  Salt Length  |                     Salt                      /
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    /                 Next (Hashed) Owner Name                      /
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                         Type Bit Maps                         /
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Hash Algorithm is a single octet. 
If Hash Algorithm is zero (no hashing), the Iterations field,
Salt Length field and Salt field are omitted. MM: not implemented

Flags field is a single octet. The following one-bit flags are defined:

     0 1 2 3 4 5 6 7
    +-+-+-+-+-+-+-+-+
    |           |W|O|
    +-+-+-+-+-+-+-+-+

* O - Opt-Out flag
* W - Wildcard flag

Iterations is represented as a 16-bit unsigned integer, with the most
significant bit first. If no hashing should be applied the Hash Algorithm
field, the Salt Length field and the Salt field MUST be ignored.

Salt Length is represented as an unsigned octet.  Salt Length
represents the length of the Salt field in octets.  If the value is
zero, the following Salt field is omitted.

Salt, if present, is encoded as a sequence of binary octets.  The
length of this field is determined by the preceding Salt Length
field.

The Next (Hashed) Owner Name is a base32 encoded domain name,
if Hash Algorithm is not zero. If Hash Algorithm is zero it is a plain
domain name.

MG: hier moeten we zeker nog zeggen dat de base32 encode domain in de zone
    valt (ala NSEC3) en anders gewoon de next name is (ala NSEC).

The Type Bit Maps encode the existing types at the original owner name
that matches the NSEC4 RR.

MM: We might be able to do something smart with the label count,
    like NSEC does.

Label Count is represented as a 8-bit unsigned integer, and represents the
number of labels of the owner name in its unhashed format. It is used to
determine the closest encloser of the name that matches the NSEC4 RR.

MM: But we still can't use it for NXDOMAIN responses. Unhashed NXDOMAIN is
    no problem, because the source of synthesis (*.closest_encloser)
    always is the next of the closest encloser. But hashed, this order is
    screwed.

## Presentation Format

The presentation format of the RDATA portion is as follows:

* The Hash Algorithm field is represented as an unsigned decimal
    integer. The value has a maximum of 255.

* The Flags field is represented as an unsigned decimal integer.
    The value has a maximum of 255.

* The Iterations field is represented as an unsigned decimal
    integer. The value is between 0 and 65535, inclusive.

* The Salt Length field is not represented.

* The Salt field is represented as a sequence of case-insensitive
  hexadecimal digits.  Whitespace is not allowed within the
  sequence.  The Salt field is represented as "-" (without the
  quotes) when the Salt Length field has a value of 0.

* The Next (Hashed) Owner Name field is represented as a domain name.

* The Type Bit Maps field is represented as a sequence of RR type
  mnemonics.  When the mnemonic is not known, the TYPE
  representation as described in Section 5 of [](#RFC3597) MUST be
  used.

NSEC record:

    example.org. NSEC a.example.org. NS SOA RRSIG DNSKEY NSEC3PARAM

NSEC3 record:

    15BG9L6359F5CH23E34DDUA6N1RIHL9H.example.org. NSEC3 1 0 2 DEAD
     22670TRPLHSR72PQQMEDLTG1KDQEOLB7 NS SOA RRSIG DNSKEY NSEC3PARAM

NSEC4 record with zero hashing:

    example.org. NSEC4 0 0 0 - a.example.org. NS SOA RRSIG DNSKEY NSEC4PARAM

NSEC4 record with hashing:

    15BG9L6359F5CH23E34DDUA6N1RIHL9H.example.org. NSEC4 1 0 2 DEAD
     22670TRPLHSR72PQQMEDLTG1KDQEOLB7.example.org.
     NS SOA RRSIG DNSKEY NSEC4PARAM

# The NSEC4PARAM Resource Record

Exactly like NSEC3PARAM described in Section 5 of [](#RFC5155),
except the type code used [TBD] is that of NSEC4PARAM.

# Calculation of the Hash

Exactly like the hash calculation of NSEC3, Section 5 of [](#RFC5155).

# Authoritative Server Considerations

## Zone Serving

This specification modifies DNSSEC-enabled DNS responses generated by
authoritative servers. In particular, it replaces the use of NSEC or
NSEC3 RRs in such responses with NSEC4 RRs.

### Denial of Source of Synthesis Proof

With NSEC3, many responses require the closest encloser proof. The closest
encloser is used to determine:

* the "next closer" name, used in a Name Error responses to proof that
  QNAME does not exist, and used in Wildcard No Data responses to proof
  that the wildcard name expansion was valid;

* the source of synthesis, used in Name Error responses to proof that
  wildcard name expansion was not possible, and used in Wildcard No Data
  responses to proof that the wildcard does not have the required RRset.

* the RRsets at the closest encloser, used to determine if the denial
  of existence is from the proper zone and does not cross authoritative
  boundaries.

In many cases, it is actually not a necessity to transmit the closest
encloser, it is just for convenience. The closest encloser is only
required for the authenticated denial of existence of the source of
synthesis. This has now been covered with that addition of the Wildcard
bit in the Flags field.

The Denial of Source of Synthesis proof consists of one NSEC4 RR, that:

* matches the closest (provable) encloser;
* has the Wildcard bit not set.

This is a proof that some ancestor of the QNAME is the closest encloser of
QNAME. To proof that no wildcard expansion was possible, we check that the
Wildcard bit was not set.

### Name Error Responses

If the zone does not contain any RRsets matching QNAME either exactly or
via wildcard name expansion, then the name server must include proof that:

* there is no exact match for QNAME;
* the zone contains no RRsets that would match QNAME via wildcard name expansion.

With NSEC, the server includes in the response a NSEC RR that covers QNAME,
and a NSEC RR that covers the wildcard RR at the closest encloser.

With NSEC3, the server includes in the response a NSEC3 RR that covers the
next closer, a NSEC3 RR that covers the wildcard RR at the closest
encloser, and a NSEC3 RR that matches the closest encloser.

MM: Instead or returning the NSEC3 RR that covers the next closer,
    the server could have returned the NSEC3 RR that covers the QNAME in
    order to proof that there is no exact match for QNAME.

To prove the nonexistence of QNAME with NSEC4, the server MUST include in
the response a NSEC4 RR that covers the next closer, and a NSEC4 RR that
matches the closest encloser. The NSEC4 RR that matches the closest
encloser MUST NOT have the Wildcard bit set in the Flags field.

### No Data Responses

When a NODATA response needs to be returned, it is safe to say that QNAME
exists. Just like with NSEC and NSEC3, if the QTYPE does not equal DS,
the server MUST include the NSEC4 RR that matches QNAME. This NSEC4 RR
MUST NOT have the bits corresponding to either the QTYPE or CNAME set in
its Type Bit Maps field.

Because of Opt-Out, the response can be different when QTYPE is DS. If no
NSEC4 RR matches QNAME, the server MUST return a closest provable encloser
proof for QNAME. In other words, the server MUST include in the response
a NSEC4 RR that covers the next closer, and a NSEC4 RR that matches the
closest provable encloser. Note that we do not need to proof the
nonexistence of the source of synthesis, because a DS RRset next to a
wildcard is meaningless (Section 4.6, [](#RFC4592)).

### Wildcard Answer Responses

If the zone does not contain any RRsets matching QNAME, but there is
wildcard name expansion possible then the name server must include proof
that the wildcard match was valid. This proof is accomplished by proving
that QNAME does not exist and that the closest encloser of QNAME and the
immediate ancestor of the wildcard are equal.

Both with NSEC and NSEC3, the server includes in the response a NSEC RR
that covers the next closer. It is not necessary to return a RR that
matches the closest encloser, as the existence of this closest encloser
is proven by the presence of the expanded wildcard in the response.

To prove that the wildcard name expansion was valid with NSEC4, the server
MUST include in the response a NSEC4 RR that covers the next closer.

### Wildcard No Data Responses

With NSEC, the server includes in the response a NSEC RR that matches the
wildcard, in addition to the the NSEC RR that covers the next closer. The
NSEC RR does not have the bits corresponding to QTYPE or CNAME set in its
Type Bit Maps field.

Again, with NSEC3, the server includes in the response a NSEC3 RR that
matches the wildcard, in addition to the the NSEC3 RR that covers the next
closer. The NSEC3 RR does not have the bits corresponding to QTYPE or
CNAME set in its Type Bit Maps field. Besides that, a NSEC3 RR that
matches the closest encloser is included, because there was no expanded
wildcard in the response that can be used to determine the closest
encloser.

To prove the wildcard no data response with NSEC4, the server MUST include
in the response a NSEC4 RR that matches the wildcard, and a NSEC4 RR that
covers the next closer. We do not need to include a RR that matches the
closest encloser, as it can be derived from the NSEC4 RR that matches the
wildcard. From that, the next closer can be derived.

### Referrals to Unsigned Subzones

Like "serving-no-data-responses" with QYTPE is DS.

### Responding to Queries for NSEC4 Owner Names
Queries for NSEC4 owner names are handled in the same way as normal
queries. When NSEC4 hashing is in effect the paradox (NSEC4 records
deny their own existence) described in Section 7.2.8 of [](#RFC5155)
is back. In light of this paradox validating resolvers SHOULD NOT
use the information from NSEC4 queries.

### Server Response to a Run-Time Collision

The same considerations as described in Section 7.2.9 of [](#RFC5155) apply.

# IANA Considerations

This memo includes requests to IANA.
Almost the same, except remove the reserved status of the zero hash.

# Security Considerations

This document does not introduce any new security issues beyond those
already discussed in [](#RFC4033), [](#RFC4034), [](#RFC4035) and [](#RFC5155),

# Changelog

## 00

- Initial document
