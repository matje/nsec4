# Authoritative Server Considerations

## Zone Signing

[MM: Almost the same, except considerations for the wildcard flag.]

## Zone Serving

This specification modifies DNSSEC-enabled DNS responses generated by
authoritative servers. In particular, it replaces the use of NSEC or
NSEC3 RRs in such responses with NSEC4 RRs.

### Denial of Source of Synthesis Proof

With NSEC3, many responses require the closest encloser proof. The closest
encloser is used to determine:

* the "next closer" name, used in a Name Error responses to proof that
  QNAME does not exist, and used in Wildcard No Data responses to proof
  that the wildcard name expansion was valid;

* the source of synthesis, used in Name Error responses to proof that
  wildcard name expansion was not possible, and used in Wildcard No Data
  responses to proof that the wildcard does not have the required RRset;

* the RRsets at the closest encloser, used to determine if the denial
  of existence is from the proper zone and does not cross authoritative
  boundaries.

In many cases, it is actually not a necessity to transmit the closest
encloser, it is just for convenience. The closest encloser is only
required for the authenticated denial of existence of the source of
synthesis. This has now been covered with the addition of the Wildcard
bit in the Flags field.

The Denial of Source of Synthesis proof consists of one NSEC4 RR, that:

* matches the closest (provable) encloser;
* has the Wildcard bit not set.

This is a proof that some ancestor of the QNAME is the closest encloser of
QNAME. To proof that no wildcard expansion was possible, we check that the
Wildcard bit was not set.

### Name Error Responses

If the zone does not contain any RRsets matching QNAME either exactly or
via wildcard name expansion, then the name server must include proof that:

* there is no exact match for QNAME;
* the zone contains no RRsets that would match QNAME via wildcard name
  expansion.

With NSEC, the server includes in the response a NSEC RR that covers QNAME,
and a NSEC RR that covers the wildcard RR at the closest encloser.

With NSEC3, the server includes in the response a NSEC3 RR that covers the
next closer, a NSEC3 RR that covers the wildcard RR at the closest
encloser, and a NSEC3 RR that matches the closest encloser.

[MM: Instead or returning the NSEC3 RR that covers the next closer,
     the server could have returned the NSEC3 RR that covers the QNAME in
     order to proof that there is no exact match for QNAME.]

To prove the nonexistence of QNAME with NSEC4, the server MUST include in
the response a NSEC4 RR that covers the next closer, and a NSEC4 RR that
matches the closest encloser. The NSEC4 RR that matches the closest
encloser MUST have the Wildcard bit clear in the Flags field  (note that
this is true by definition -- if the Wildcard bit is not clear, the source
of synthesis exists and the response should have resulted in a wildcard name
expansion).

### No Data Responses

When a NODATA response needs to be returned, it is safe to say that QNAME
exists. Just like with NSEC and NSEC3, if the QTYPE does not equal DS,
the server MUST include the NSEC4 RR that matches QNAME. This NSEC4 RR
MUST NOT have the bits corresponding to either the QTYPE or CNAME set in
its Type Bit Maps field.

Because of Opt-Out, the response can be different when QTYPE is DS. If no
NSEC4 RR matches QNAME, the server MUST return a closest provable encloser
proof for QNAME. In other words, the server MUST include in the response
a NSEC4 RR that covers the next closer, and a NSEC4 RR that matches the
closest provable encloser. Note that we do not need to proof the
nonexistence of the source of synthesis, because a DS RRset next to a
wildcard is meaningless (Section 4.6, [](#RFC4592)).

### Wildcard Answer Responses

If the zone does not contain any RRsets matching QNAME, but there is
wildcard name expansion possible then the name server must include proof
that the wildcard match was valid. This proof is accomplished by proving
that QNAME does not exist and that the closest encloser of QNAME and the
immediate ancestor of the wildcard are equal.

Both with NSEC and NSEC3, the server includes in the response a NSEC RR
that covers the next closer. It is not necessary to return a RR that
matches the closest encloser, as the existence of this closest encloser
is proven by the presence of the expanded wildcard in the response.

To prove that the wildcard name expansion was valid with NSEC4, the server
MUST include in the response a NSEC4 RR that covers the next closer.

### Wildcard No Data Responses

With NSEC, the server includes in the response a NSEC RR that matches the
wildcard, in addition to the the NSEC RR that covers the next closer. The
NSEC RR does not have the bits corresponding to QTYPE or CNAME set in its
Type Bit Maps field.

Again, with NSEC3, the server includes in the response a NSEC3 RR that
matches the wildcard, in addition to the the NSEC3 RR that covers the next
closer. The NSEC3 RR does not have the bits corresponding to QTYPE or
CNAME set in its Type Bit Maps field. Besides that, a NSEC3 RR that
matches the closest encloser is included, because there was no expanded
wildcard in the response that can be used to determine the closest
encloser.

To prove the wildcard no data response with NSEC4, the server MUST include
in the response a NSEC4 RR that matches the wildcard, and a NSEC4 RR that
covers the next closer. We do not need to include a RR that matches the
closest encloser, as it can be derived from the NSEC4 RR that matches the
wildcard. From that, the next closer can be derived.

### Referrals to Unsigned Subzones

[MM: Like [](#no-data-responses) with QYTPE is DS.]

### Responding to Queries for NSEC4 Owner Names

Queries for NSEC4 owner names are handled in the same way as normal
queries. When NSEC4 hashing is in effect the paradox (NSEC4 records
deny their own existence) described in Section 7.2.8 of [](#RFC5155)
is back. In light of this paradox, then the response MUST be constructed
as a Name Error response ([](#name-error-responses). Or, in other words,
the authoritative name server will act as if the owner name of the NSEC4 RR
did not exist.

### Server Response to a Run-Time Collision

The same considerations as described in Section 7.2.9 of [](#RFC5155) apply.

## Secondary Servers

[MM: Like [](#RFC5155), Section 7.3]

## Zones Using Unknown Hash Algorithms

[MM: Like [](#RFC5155), Section 7.4]

## Dynamic Update

[MM: Similar to [](#RFC5155), Section 7.5, but special considerations
for adding and removing wildcard RRs.]

# Validator Considerations

## Responses with Unknown Hash Types

A validator MUST ignore NSEC4 RRs with unknown hash types.  The
practical result of this is that responses containing only such NSEC4
RRs will generally be considered bogus.

## Verifying NSEC4 RRs

A validator MUST ignore NSEC4 RRs with a Flag fields value greater than
three.

A validator MAY treat a response as bogus if the response contains
NSEC4 RRs that contain different values for hash algorithm,
iterations, or salt from each other for that zone.

## Validating Name Error Responses
A validator MUST verify that there is a closest encloser for QNAME present
in the response. A validator MUST verify that the Wildcard bit is clear in
the Flags field of the NSEC4 RR that matches the closest encloser.

In order to find the closest encloser, the validator MUST find the longest
name, X, such that X is an ancestor of QNAME that is matched by a NSEC4 RR
present in the response.

[MM: Why is it that with NSEC3 it is merely a candidate for the closest
     encloser?]
[MG: I *think* because of Opt-Out, but frankly I don't know]

One possible algorithm for finding the closest encloser is as follows:

1.  Set SNAME=QNAME.
2.  If there is a NSEC4 RR in the response that matches SNAME, then we have
    found the closest encloser.
3.  Truncate SNAME by one label from the left, go to step 2.
4.  [MG: je moet hier heel erg letten op hoeveel labels je moet comparen,
    bij alg == 0, namelijk de hele naam, en bij alg != 0 alleen het eerste
    label.

Once the closest encloser has been discovered, the validator MUST
check that the NSEC4 RR that has the closest encloser as the original
owner name is from the proper zone. The DNAME type bit MUST NOT be set and
the NS type bit MUST be clear if the SOA type bit is clear.

If this is not the case, it would be an indication that an attacker is
using them to falsely deny the existence of RRs for which the server is
not authoritative.

In addition, the validator MUST verify that there is a NSEC4 RR that covers
the "next closer" name.

## Validating No Data Responses

If QTYPE is not DS, a validator MUST verify that a NSEC4 RR that matches
QNAME is present and that both the QTYPE and the CNAME type are not set in
its Type Bit Maps field.

Note that this test also covers the case where the NSEC4 RR exists because
it corresponds to an empty non-terminal, in which case the NSEC4 RR will
have an empty Type Bit Maps field.

If QTYPE is DS, and there is a NSEC4 RR that matches QNAME present in the
response, then that NSEC4 RR MUST NOT have the bits corresponding to DS and
CNAME set in its Type Bit Maps field.

If there is no such NSEC4 RR, then the validator MUST verify that there is
a closest provable encloser for QNAME present in the response. The closest
provable encloser is found in a similar way as the closest encloser.
In addition, the validator MUST verify that there is a NSEC4 RR that covers
the "next closer" name and has the Opt-Out bit set.

## Validating Wildcard Answer Responses

The verified wildcard answer RRSet in the response provides the validator
with a closest encloser for QNAME. 

The validator MUST verify that there is a NSEC4 RR that covers the
"next closer" name to QNAME is present in the response. This proves that QNAME
itself did not exist and that the correct wildcard was used to generate the
response.

## Validating Wildcard No Data Responses

The validator MUST verify that there is a NSEC4 RR present in the response
that matches the source of synthesis. 

In order to find the source of synthesis, the validator MUST find the longest
name, X, such that X is an ancestor of QNAME and that *.X is matched by a
NSEC4 RR present in the response.

One possible algorithm for finding the source of synthesis is as follows:

1.  Set SNAME=QNAME.
2.  Truncate SNAME by one label from the left. This is a candidate for the
    closest encloser.
3.  Set WNAME to be SNAME with the asterisk label prepended: WNAME=*.SNAME.
4.  If there is a NSEC4 RR in the response that matches WNAME, then we have
    found the source of synthesis, with SNAME being the closest encloser.
5.  Go to step 2.

The validator does not need to check that the closest encloser is from the
proper zone. The authoritative server returned a NSEC4 that matches the
source of synthesis. According to [](#RFC2672), this proves that
the server did not encounter a referral (step 3b of the server algorithm),
nor did it encounter a DNAME (step 3c of the server algorithm).

Now that the validator knows the source of synthesis and thus the closest
encloser, it can derive the "next closer" name. The validator MUST verify
that there is a NSEC4 RR that covers the "next closer" name to QNAME is
present in the response.

## Validating Referrals to Unsigned Subzones

The delegation name in a referral is the owner name of the NS RRSet
present in the authority section of the referral response.

If there is an NSEC4 RR present in the response that matches the
delegation name, then the validator MUST ensure that the NS bit is
set and that the DS bit is not set in the Type Bit Maps field of the
NSEC4 RR. The validator MUST also ensure that the NSEC4 RR is from
the correct (i.e., parent) zone. This is done by ensuring that the
SOA bit is not set in the Type Bit Maps field of this NSEC4 RR.

Note that the presence of an NS bit implies the absence of a DNAME
bit, so there is no need to check for the DNAME bit in the Type Bit
Maps field of the NSEC4 RR.

If there is no NSEC4 RR present that matches the delegation name,
then the validator MUST verify that there is a closest provable encloser 
for the delegation name. In addition, the validator MUST verify that
there is a NSEC4 RR that covers the "next closer" name and has the
Opt-Out bit set.

# Resolver Considerations

## NSEC3 Resource Record Caching

[MM: Like [](#RFC5155), Section 9.1]

## Use of the AD Bit

[MM: Like [](#RFC5155), Section 9.2]

# IANA Considerations

This memo includes requests to IANA.
Almost the same, except remove the reserved status of the zero hash.

# Security Considerations

This document does not introduce any new security issues beyond those
already discussed in [](#RFC4033), [](#RFC4034), [](#RFC4035) and [](#RFC5155),

# Changelog

## 00

- Initial document
