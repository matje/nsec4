# Authoritative Server Considerations

## Zone Signing

Zones using NSEC4 must satisfy the same properties as described in 
Section 7.1 of [](#RFC5155), with NSEC3 replaced by NSEC4.

In addition, for each original owner name where wildcard synthesis is possible,
the corresponding NSEC4 RR MUST have the Wildcard bit set in the Flags field.

The following steps describe one possible method of proper construction of
NSEC4 RRs.

1.  Select the hash algorithm and the values for salt and iterations;

2.  For each unique original owner name in the zone add a NSEC4 RR;
    * If Opt-Out is being used, owner names of unsigned delegations MAY be excluded;
    * The owner name of the NSEC4 RR is either the hash of the original owner name, prepended as a single label to the zone name, or is equal to the original owner name if Zero hashing is used;
    * The Next Owner Name field is left blank for the moment;
    * If Opt-Out is being used, set the Opt-Out bit to one.

3.  For collision detection purposes, if hashing is used, optionally keep
    track of the original owner name with the NSEC4 RR. Create an additional
    NSEC4 RR corresponding to the original owner name with the asterisk label
    prepended. Mark this NSEC4 RR as temporary;

4.  If the original owner name is a wildcard domain name (Section 2.1.1. of [](#RFC4592)), 
    mark the NSEC4 to be a NSEC4 RR that is matching a wildcard; 

4.  For each RRSet at the original owner name, set the corresponding
    bit in the Type Bit Maps field;

5.  Additional NSEC4 RRs need to be added for every empty non-terminal
    between the apex and the original owner name. Optionally keep track of the
    original owner names of these NSEC4 RRs and create temporary NSEC4 RRs for
    wildcard collisions in a similar fashion to step 3; [MG: needs this also to
    be done when Zero hashing is used?]

6.  Sort the set of NSEC4 RRs into hash order or canonical order, depending
    on the value of the hash algorithm;

7.  Combine NSEC4 RRs with identical hashed owner names by replacing
    them with a single NSEC4 RR with the Type Bit Maps field
    consisting of the union of the types represented by the set of NSEC4 RRs. 
    If hashing is used and the original owner name was tracked, then collisions
    may be detected when combining, as all of the matching NSEC4 RRs should
    have the same original owner name. Discard any possible temporary NSEC4 RRs;

8.  In each NSEC4 RR, insert the next (hashed) owner name by using the
    value of the next NSEC4 RR in hash order.  The next hashed owner
    name of the last NSEC4 RR in the zone contains the value of the
    hashed owner name of the first NSEC4 RR in the hash order.

    If the NSEC4 is marked to be matching a wildcard, find the NSEC4 that
    matches the closest encloser. Set the Wildcard bit in the Flags field
    of that NSEC4; [MG: what about Zero hashing here?]

9.  Finally, add a NSEC4PARAM RR with the same Hash Algorithm,
    Iterations, and Salt fields to the zone apex.

If a hash collision is detected, then a new salt has to be chosen,
and the signing process is restarted.

## Zone Serving

This specification modifies DNSSEC-enabled DNS responses generated by
authoritative servers. In particular, it replaces the use of NSEC or
NSEC3 RRs in such responses with NSEC4 RRs.

### Denial of Wildcard Synthesis Proof

Instead of wasting a whole denial of existence RR to deny a wildcard, we have
introduced a bit in the Flags field of the NSEC4 RR that indicates whether
wildcard synthesis was possible at the original owner name.

The Denial of Wildcard Synthesis proof consists of one NSEC4 RR, that
matches some domain name, and that has the Wildcard bit clear.

Note that without much knowledge of the domain name, this proof is not really
useful. In particular, we don't know if this is the wildcard synthesis that
we are looking for. This changes if we combine this proof with the
closest encloser proof.

### Closest Encloser Proof

For some NSEC4 responses a proof of the closest encloser is required.
This is a proof that some ancestor of the QNAME is the closest encloser of QNAME.
The proof is described in Section 7.2.1 of [](#RFC5155), and is the same
for NSEC4.

### Denial of Source of Synthesis Proof

The denial of wildcard synthesis proof combined with the closest encloser proof
results in a denial of source of synthesis proof. The source of synthesis is
defined in [](#RFC4592) as the wildcard domain name immediately descending from
the closest encloser.

The Denial of Source of Synthesis proof consists of (up to) two NSEC4 RRs,
the same that constructed the closest encloser proof:

* a NSEC4 RR that matches the closest encloser, and that has the Wildcard bit
  clear in the Flags field;
* a NSEC4 RR that covers the next closer name to the closest encloser.

The first NSEC4 RR essentially proves that the encloser exists, and that no
wildcard synthesis at the encloser is possible.
The second NSEC4 RR proves that the encloser is the closest, thus the
denial of the wildcard synthesis is the denial of the source of synthesis.

### Name Error Responses

If the zone does not contain any RRsets matching QNAME either exactly or
via wildcard name expansion, then the name server must include proof that:

* there is no exact match for QNAME;
* the zone contains no RRsets that would match QNAME via wildcard name
  expansion.

With NSEC, the server includes in the response a NSEC RR that covers QNAME,
and a NSEC RR that covers the wildcard RR at the closest encloser.

With NSEC3, the server includes in the response a NSEC3 RR that covers the
next closer, a NSEC3 RR that covers the wildcard RR at the closest
encloser, and a NSEC3 RR that matches the closest encloser.

[MM: Instead or returning the NSEC3 RR that covers the next closer,
     the server could have returned the NSEC3 RR that covers the QNAME in
     order to proof that there is no exact match for QNAME.]

To prove the nonexistence of QNAME with NSEC4, the server MUST include a
denial of source of synthesis proof. This collection of (up to) two NSEC4 RRs
proves both that QNAME does not exist and that a wildcard that could have
matched QNAME also does not exist.

### No Data Responses

#### QTYPE is not DS

When a NODATA response needs to be returned, it is safe to say that QNAME
exists. Similar to NSEC and NSEC3, server MUST include the NSEC4 RR that
matches QNAME. This NSEC4 RR MUST NOT have the bits corresponding to either
the QTYPE or CNAME set in its Type Bit Maps field.

#### QTYPE is DS

Because of Opt-Out, the response can be different when QTYPE is DS. If no
NSEC4 RR matches QNAME, the server MUST return a closest provable encloser
proof for QNAME. The NSEC4 RR that covers the next closer name MUST have
the Opt-Out bit set.

Note that we do not need to ensure the denial of source of synthesis proof,
because a DS RRset next to a wildcard is meaningless (Section 4.6, [](#RFC4592)).

### Wildcard Answer Responses

If the zone does not contain any RRsets matching QNAME, but there is
wildcard name expansion possible then the name server must include proof
that the wildcard match was valid. This proof is accomplished by proving
that QNAME does not exist and that the closest encloser of QNAME and the
immediate ancestor of the wildcard are equal.

Both with NSEC and NSEC3, the server includes in the response a NSEC RR
that covers the next closer. It is not necessary to return a RR that
matches the closest encloser, as the existence of this closest encloser
is proven by the presence of the expanded wildcard in the response.

To prove that the wildcard name expansion was valid with NSEC4,
the server MUST include in the response a NSEC4 RR that covers the
next closer. For the same reasons as with NSEC and NSEC3, it is not necessary
to return a RR that matches the closest encloser.

### Wildcard No Data Responses

With NSEC, the server includes in the response a NSEC RR that matches the
wildcard, in addition to the NSEC RR that covers the next closer. The
NSEC RR does not have the bits corresponding to QTYPE or CNAME set in its
Type Bit Maps field.

Again, with NSEC3, the server includes in the response a NSEC3 RR that
matches the wildcard, in addition to the NSEC3 RR that covers the next
closer. The NSEC3 RR does not have the bits corresponding to QTYPE or
CNAME set in its Type Bit Maps field. Besides that, a NSEC3 RR that
matches the closest encloser is included, because there was no expanded
wildcard in the response that can be used to determine the closest
encloser.

[](#RFC5155) already notes that the closest encloser to QNAME must be the
immediate ancestor of the wildcard RR, which is also defined in [](#RFC4592).
A closest encloser proof is not necessitated.

To prove the wildcard no data response with NSEC4, the server MUST include
in the response a NSEC4 RR that matches the wildcard, and a NSEC4 RR that
covers the next closer. The closest encloser can be derived from the NSEC4 RR
that matches the wildcard. From that, the next closer can be derived.

### Referrals to Unsigned Subzones

If there is an NSEC4 RR that matches the delegation name, then that
NSEC4 RR MUST be included in the response. The DS and CNAME bit in the type
bit maps of the NSEC4 RR MUST NOT be set.

If the zone is Opt-Out, then there may not be an NSEC4 RR corresponding to
the delegation. In this case, the closest provable encloser proof MUST be
included in the response. The included NSEC4 RR that covers the "next closer"
name for the delegation MUST have the Opt-Out flag set to one.

Note that with Zero hashing, the NSEC4 RR that matches the closest provable
encloser does not need to be included in the response, as it can be
derived from the NSEC4 that covers the "next closer" name.

### Responding to Queries for NSEC4 Owner Names

Queries for NSEC4 owner names are handled in the same way as normal
queries. When NSEC4 hashing is in effect the paradox (NSEC4 records
deny their own existence) described in Section 7.2.8 of [](#RFC5155)
is back. In light of this paradox, then the response MUST be constructed
as a Name Error response (see [](#name-error-responses)). Or, in other words,
the authoritative name server will act as if the owner name of the NSEC4 RR
did not exist.

[MG: Why return a Name Error response? It might be useful to query for
     Denial of Existence RRs, esp. when Zero hashing is in use??]

### Server Response to a Run-Time Collision

The same considerations as described in Section 7.2.9 of [](#RFC5155) for
NSEC3 apply to NSEC4.

## Secondary Servers

The same considerations as described in Section 7.3 of [](#RFC5155) for
NSEC3 and NSEC3PARAM apply to NSEC4 and NSEC4PARAM.

## Zones Using Unknown Hash Algorithms

The same considerations as described in Section 7.4 of [](#RFC5155) for
NSEC3 apply to NSEC4.

## Dynamic Update

A zone signed using NSEC4 may accept dynamic updates [](#RFC2136).
However, NSEC4 introduces some special considerations for dynamic updates.

Adding and removing names in a zone MUST account for the creation or
removal of empty non-terminals, similar to [](#RFC5155), Section 7.5.

The presence of Opt-Out in a zone means that some additions or removals of
unsigned delegations of names will not require changes to the NSEC4 RRs in a
zone. The same considerations as in [](#RFC5155), Section 7.5 for NSEC3 apply
for NSEC4.

The presence of Opt-Out in a zone means that when adding or removing
NSEC4 RRs, the value of the Opt-Out flag that should be set in new or
modified NSEC4 RRs is ambiguous. Servers SHOULD follow the set of
basic rules to resolve the ambiguity, as described in [](#RFC5155),
Section 7.5.

Adding and removing wildcard names in a zone MUST account for the setting
or clearing of the Wildcard bit in the Flags field:

* When adding a wildcard name, the NSEC4 RR that matches the immediate
  parent of the wildcard MUST set the Wildcard bit in the Flags field;

* When deleting a wildcard name, the NSEC4 RR that matches the immediate
  parent of the wildcard MUST clear the Wildcard bit in the Flags field.

# Validator Considerations

## Responses with Unknown Hash Types

A validator MUST ignore NSEC4 RRs with unknown hash types.  The
practical result of this is that responses containing only such NSEC4
RRs will generally be considered bogus.

## Verifying NSEC4 RRs

A validator MUST ignore NSEC4 RRs with a Flag fields value greater than
three.

A validator MAY treat a response as bogus if the response contains
NSEC4 RRs that contain different values for hash algorithm,
iterations, or salt from each other for that zone.

## Validating Name Error Responses

A validator MUST verify that there is a closest encloser for QNAME present
in the response. A validator MUST verify that the Wildcard bit is clear in
the Flags field of the NSEC4 RR that matches the closest encloser.

In order to find the closest encloser, the validator MUST find the longest
name, X, such that X is an ancestor of QNAME that is matched by a NSEC4 RR
present in the response.

One possible algorithm for finding the closest encloser is as follows:

1. Set SNAME=QNAME;
2. If there is a NSEC4 RR in the response that matches SNAME, then we have found the closest encloser;
3. Truncate SNAME by one label from the left, go to step 2.

Once the closest encloser has been discovered, the validator MUST
check that the NSEC4 RR that has the closest encloser as the original
owner name is from the proper zone. The DNAME type bit MUST NOT be set and
the NS type bit MUST be clear if the SOA type bit is clear.

If this is not the case, it would be an indication that an attacker is
using them to falsely deny the existence of RRs for which the server is
not authoritative.

In addition, the validator MUST verify that there is a NSEC4 RR that covers
the next closer name.

## Validating No Data Responses

If QTYPE is not DS, a validator MUST verify that a NSEC4 RR that matches
QNAME is present and that both the QTYPE and the CNAME type are not set in
its Type Bit Maps field.

Note that this test also covers the case where the NSEC4 RR exists because
it corresponds to an empty non-terminal, in which case the NSEC4 RR will
have an empty Type Bit Maps field.

If QTYPE is DS, and there is a NSEC4 RR that matches QNAME present in the
response, then that NSEC4 RR MUST NOT have the bits corresponding to DS and
CNAME set in its Type Bit Maps field.

If there is no such NSEC4 RR, then the validator MUST verify that there is
a closest provable encloser for QNAME present in the response. The closest
provable encloser is found in a similar way as the closest encloser.
In addition, the validator MUST verify that there is a NSEC4 RR that covers
the next closer name and has the Opt-Out bit set.

## Validating Wildcard Answer Responses

The verified wildcard answer RRSet in the response provides the validator
with a closest encloser for QNAME. The validator can do so by checking the
label count in the RRSIG and the number of labels in the answer's owner name.

The validator MUST verify that there is a NSEC4 RR that covers the
next closer name to QNAME is present in the response. This proves that QNAME
itself did not exist and that the correct wildcard was used to generate the
response.

## Validating Wildcard No Data Responses

The validator MUST verify that there is a NSEC4 RR present in the response
that matches the source of synthesis. 

In order to find the source of synthesis, the validator MUST find the longest
name, X, such that X is an ancestor of QNAME and that *.X is matched by a
NSEC4 RR present in the response.

One possible algorithm for finding the source of synthesis is as follows:

1.  Set SNAME=QNAME;
2.  Truncate SNAME by one label from the left. This is a candidate for the
    closest encloser;
3.  Set WNAME to be SNAME with the asterisk label prepended: WNAME=*.SNAME;
4.  If there is a NSEC4 RR in the response that matches WNAME, then we have
    found the source of synthesis, with SNAME being the closest encloser;
5.  Go to step 2.

The validator does not need to check that the closest encloser is from the
proper zone. The authoritative server returned a NSEC4 that matches the
source of synthesis. According to [](#RFC2672), this proves that
the server did not encounter a referral (step 3b of the server algorithm [](#RFC1035)),
nor did it encounter a DNAME (step 3c of the server algorithm [](#RFC1035)).

Now that the validator knows the source of synthesis and thus the closest
encloser, it can derive the next closer name. The validator MUST verify
that there is a NSEC4 RR that covers the next closer name to QNAME, is
present in the response.

Note that, because the response included a NSEC4 that matches the source
of synthesis, we know that there exists data in the zone below the closest
encloser. Therefore, the closest encloser cannot be a delegation, nor can there
exists a DNAME RRset at the closest encloser.

## Validating Referrals to Unsigned Subzones

The delegation name in a referral is the owner name of the NS RRSet
present in the authority section of the referral response.

If there is a NSEC4 RR present in the response that matches the
delegation name, then the validator MUST ensure that the NS bit is
set and that the DS bit is not set in the Type Bit Maps field of the
NSEC4 RR. The validator MUST also ensure that the NSEC4 RR is from
the correct (i.e., parent) zone. This is done by ensuring that the
SOA bit is not set in the Type Bit Maps field of this NSEC4 RR.

Note that the presence of a NS bit implies the absence of a DNAME
bit, so there is no need to check for the DNAME bit in the Type Bit
Maps field of the NSEC4 RR.

If there is no NSEC4 RR present that matches the delegation name,
then the validator MUST verify that there is a closest provable encloser 
for the delegation name. In addition, the validator MUST verify that
there is a NSEC4 RR that covers the next closer name and has the
Opt-Out bit set.

# Resolver Considerations

## NSEC3 Resource Record Caching

The same considerations as described in Section 9.1 of [](#RFC5155) for
NSEC3 apply to NSEC4.

## Use of the AD Bit

The same considerations as described in Section 9.2 of [](#RFC5155) for
NSEC3 apply to NSEC4.

# Special Considerations

## Domain Name Length Restrictions

The same considerations as described in Section 10.1 of [](#RFC5155) apply.

## DNAME at the Zone Apex

The DNAME specification in Section 3 of [](#RFC2672) has a
'no-descendants' limitation. If a DNAME RR is present at node N,
there MUST be no data at any descendant of N.

[](#RFC5155) updates the DNAME specification to allow NSEC3 and RRSIG types
at descendants of the apex regardless of the existence of DNAME at the apex.

This document updates the DNAME specification to also allow NSEC4 types
at descendants of the apex regardless of the existence of DNAME at the apex.

## Iterations value

Like Section 10.3 in [](#RFC5155), but we recommend to
read [](#Schaeffer10) as it shows that a lower iterations value
is also acceptable. The research shows that that the half performance count
for validators is roughly 150 to 600, depending on the key size.
For authoritative servers the half performance count is around 100 iterations.

## More Special Considerations

[](#RFC5155), Appendix C clarifies specific behavior and explains
more special considerations for implementations, regarding salting and
hash collisions. These considerations for NSEC3 also apply to NSEC4.

# IANA Considerations

Although the NSEC4 and NSEC4PARAM RR formats include a hash algorithm
parameter, this document does not define a particular mechanism for
safely transitioning from one NSEC4 hash algorithm to another. When
specifying a new hash algorithm for use with NSEC4, a transition
mechanism MUST also be defined.

This document updates the IANA registry "DOMAIN NAME SYSTEM PARAMETERS"
(http://www.iana.org/assignments/dns-parameters) in sub-registry "TYPES",
by defining two new types. [](#the-nsec4-resource-record) defines the
NSEC4 RR type [TBD]. [](#the-nsec4param-resource-record) defines the
NSEC4PARAM RR type [TBD].

This document possibly updates the IANA registry
"DNS SECURITY ALGORITHM NUMBERS -- per [](#RFC4035)"
(http://www.iana.org/assignments/dns-sec-alg-numbers). 

This document creates a new IANA registry for NSEC4 flags. This
registry is named "DNSSEC NSEC4 Flags". The initial contents of this
registry are:

      0    1    2    3    4    5    6    7
    +----+----+----+----+----+----+----+----+
    |    |    |    |    |    |    |Wild|Opt-|
    |    |    |    |    |    |    |card|Out |
    +----+----+----+----+----+----+----+----+

    bit 6 is the Wildcard flag.

    bit 7 is the Opt-Out flag.

    bits 0 - 5 are available for assignment.

Assignment of additional NSEC4 Flags in this registry requires IETF
Standards Action [](#RFC5226).

This document creates a new IANA registry for NSEC4PARAM flags. This
registry is named "DNSSEC NSEC4PARAM Flags". The initial contents of
this registry are:

      0   1   2   3   4   5   6   7
    +---+---+---+---+---+---+---+---+
    |   |   |   |   |   |   |   | 0 |
    +---+---+---+---+---+---+---+---+

    bit 7 is reserved and must be 0.

    bits 0 - 6 are available for assignment.

Assignment of additional NSEC4PARAM Flags in this registry requires IETF
Standards Action [](#RFC5226).

Finally, this document creates a new IANA registry for NSEC4 hash
algorithms. This registry is named "DNSSEC NSEC4 Hash Algorithms".
The initial contents of this registry are:

    0 is Zero hashing.

    1 is SHA-1.

    2-255 Available for assignment.

Assignment of additional NSEC4 hash algorithms in this registry requires IETF
Standards Action [](#RFC5226).

# Security Considerations

This document does not introduce any new security issues beyond those
already discussed in [](#RFC4033), [](#RFC4034), [](#RFC4035) and [](#RFC5155),

# Acknowledgements
This document would not be possible without the help of Ed Lewis, Roy Arends, Wouter
Wijngaards, Marco Davids, Esther Makaay and Antoin Verschuren.

# Changelog

## 00

* Initial document
